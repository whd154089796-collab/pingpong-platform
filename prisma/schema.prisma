generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserRole {
  user
  admin
}

enum MatchType {
  single
  double
  team
}

enum MatchStatus {
  registration
  ongoing
  finished
}

enum RegistrationRole {
  player
  captain
  substitute
}

enum RegistrationStatus {
  registered
  cancelled
  confirmed
}

enum PointsTransactionType {
  earn
  spend
  adjustment
  refund
}

enum RewardType {
  physical
  digital
  coupon
}

model User {
  id               String    @id @default(cuid())
  email            String    @unique
  nickname         String
  avatarUrl        String?
  points           Int       @default(0)
  eloRating        Int       @default(1200)
  isBanned         Boolean   @default(false)
  role             UserRole  @default(user)
  wins             Int       @default(0)
  losses           Int       @default(0)
  matchesPlayed    Int       @default(0)
  authProviderId   String?   @unique
  hashedPassword   String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  createdMatches   Match[]              @relation("MatchCreator")
  registrations    Registration[]
  wonResults       MatchResult[]        @relation("ResultWinner")
  lostResults      MatchResult[]        @relation("ResultLoser")
  reportedResults  MatchResult[]        @relation("ResultReporter")
  verifiedResults  MatchResult[]        @relation("ResultVerifier")
  eloHistory       EloHistory[]
  pointsLedger     PointsTransaction[]
  redemptions      RewardRedemption[]
  awardedBadges    UserBadge[]
  reviewsGiven     Review[]             @relation("Reviewer")
  reviewsReceived  Review[]             @relation("Reviewee")
  auditLogs        AuditLog[]
}

model Match {
  id               String          @id @default(cuid())
  title            String
  description      String?
  dateTime         DateTime
  location         String?
  type             MatchType
  status           MatchStatus     @default(registration)
  maxParticipants  Int
  createdBy        String
  rule             Json?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  creator          User            @relation("MatchCreator", fields: [createdBy], references: [id])
  registrations    Registration[]
  results          MatchResult[]
  eloHistory       EloHistory[]
  reviews          Review[]
}

model Registration {
  id               String             @id @default(cuid())
  matchId          String
  userId           String
  role             RegistrationRole   @default(player)
  status           RegistrationStatus @default(registered)
  createdAt        DateTime           @default(now())

  match             Match             @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([matchId, userId])
  @@index([userId])
}

model MatchResult {
  id               String     @id @default(cuid())
  matchId          String
  winnerId         String
  loserId          String
  score            Json
  reportedBy       String
  confirmed        Boolean    @default(false)
  resultVerifiedAt DateTime?
  verifierId       String?
  createdAt        DateTime   @default(now())

  match            Match      @relation(fields: [matchId], references: [id], onDelete: Cascade)
  winner           User       @relation("ResultWinner", fields: [winnerId], references: [id])
  loser            User       @relation("ResultLoser", fields: [loserId], references: [id])
  reporter         User       @relation("ResultReporter", fields: [reportedBy], references: [id])
  verifier         User?      @relation("ResultVerifier", fields: [verifierId], references: [id])
  eloHistory       EloHistory[]

  @@unique([matchId, winnerId, loserId])
  @@index([winnerId])
  @@index([loserId])
}

model EloHistory {
  id               String    @id @default(cuid())
  userId           String
  matchId          String?
  eloBefore        Int
  eloAfter         Int
  delta            Int
  createdAt        DateTime  @default(now())

  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  match            Match?    @relation(fields: [matchId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt])
}

model PointsTransaction {
  id               String                 @id @default(cuid())
  userId           String
  amount           Int
  balanceAfter     Int
  type             PointsTransactionType
  reason           String
  referenceId      String?
  createdAt        DateTime               @default(now())

  user             User                   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([referenceId])
}

model Reward {
  id               String             @id @default(cuid())
  title            String
  description      String?
  pointsCost       Int
  stock            Int?
  type             RewardType
  metadata         Json?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt

  redemptions      RewardRedemption[]
}

model RewardRedemption {
  id               String    @id @default(cuid())
  rewardId         String
  userId           String
  pointsSpent      Int
  status           String    @default("created")
  createdAt        DateTime  @default(now())

  reward           Reward    @relation(fields: [rewardId], references: [id])
  user             User      @relation(fields: [userId], references: [id])

  @@index([rewardId])
  @@index([userId, createdAt])
}

model Badge {
  id               String    @id @default(cuid())
  title            String
  description      String?
  iconUrl          String?
  createdAt        DateTime  @default(now())

  userBadges       UserBadge[]
}

model UserBadge {
  id               String    @id @default(cuid())
  userId           String
  badgeId          String
  awardedAt        DateTime  @default(now())

  user             User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge            Badge     @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  @@index([badgeId])
}

model Review {
  id               String    @id @default(cuid())
  reviewerId       String
  revieweeId       String
  matchId          String
  scores           Json
  comment          String?
  createdAt        DateTime  @default(now())

  reviewer         User      @relation("Reviewer", fields: [reviewerId], references: [id], onDelete: Cascade)
  reviewee         User      @relation("Reviewee", fields: [revieweeId], references: [id], onDelete: Cascade)
  match            Match     @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([reviewerId, revieweeId, matchId])
  @@index([revieweeId, createdAt])
}

model AuditLog {
  id               String    @id @default(cuid())
  actorId          String?
  action           String
  entityType       String
  entityId         String
  details          Json?
  createdAt        DateTime  @default(now())

  actor            User?     @relation(fields: [actorId], references: [id], onDelete: SetNull)

  @@index([entityType, entityId])
  @@index([createdAt])
}

model LeaderboardCache {
  id               String    @id @default(cuid())
  scope            String
  rank             Int
  userId           String
  points           Int
  eloRating        Int
  wins             Int
  losses           Int
  matchesPlayed    Int
  snapshotAt       DateTime

  @@unique([scope, rank, snapshotAt])
  @@index([userId, snapshotAt])
}

model RankingSnapshot {
  id               String    @id @default(cuid())
  scope            String
  payload          Json
  createdAt        DateTime  @default(now())

  @@index([scope, createdAt])
}
